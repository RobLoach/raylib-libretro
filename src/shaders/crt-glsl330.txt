"#version 330\n"
"\n"
"precision mediump float;\n"
"\n"
"// Input vertex attributes (from vertex shader)\n"
"in vec2 fragTexCoord;\n"
"in vec4 fragColor;\n"
"out vec4 finalColor;\n"
"\n"
"// Input uniform values\n"
"uniform sampler2D texture0;\n"
"uniform vec4 colDiffuse;\n"
"\n"
"#define\tTEX2D(c) texture(texture0, c)\n"
"#define FIX(c) max(abs(c), 1e-5);\n"
"#define PI 3.141592654\n"
"\n"
"float Gamma = 2.0;\n"
"float MonitorGamma = 2.4;\n"
"float Overscan = 0.99;\n"
"\n"
"uniform float Brightness;\n"
"uniform float ScanlineIntensity;\n"
"uniform bool Curvature;\n"
"uniform float CurvatureRadius;\n"
"uniform float CornerSize;\n"
"uniform float Cornersmooth;\n"
"uniform bool Border;\n"
"\n"
"uniform vec2 resolution;\n"
"\n"
"vec4 scanlineWeights(float distance, vec4 color) {\n"
"\tvec4 wid = 2.0 * pow(color, vec4(4.0)) + 6.0;\n"
"\tvec4 weights = vec4(distance * 1.32);        \n"
"\treturn 0.51 * exp(-pow(weights * sqrt(2.0 / wid), wid)) / (0.48 + 0.06 * wid);\n"
"}\n"
"\n"
"float corner(vec2 coord) {\n"
"    coord = (coord - 0.5) * vec2(Overscan, Overscan) + 0.5;\n"
"\tcoord = min(coord, 1.0 - coord) * vec2(0.7,1.0);\n"
"\tvec2 cdist = vec2(CornerSize/100.0);\n"
"\tcoord = (cdist - min(coord,cdist));\n"
"\tfloat dist = sqrt(dot(coord,coord));\n"
"    return clamp((cdist.x-dist) * Cornersmooth, 0.0, 1.0); \n"
"}\n"
"\n"
"vec2 radialDistortion(vec2 coord) {\n"
"  vec2 cc = coord - vec2(0.5);\n"
"  float dist = dot(cc, cc) * CurvatureRadius;\n"
"  return coord + cc * (1.0 - dist) * dist;\n"
"}\n"
"\n"
"void main() {\n"
"\tvec2 one = 1.0 / resolution;\n"
"\n"
"\tvec2 _xy = (Curvature) ? radialDistortion(fragTexCoord) : fragTexCoord;\n"
"\n"
"\tvec2 ratio_scale = _xy * resolution - 0.5;\n"
"\tvec2 uv_ratio = fract(ratio_scale);\n"
"\t\n"
"\tfloat cval = 1.0;\n"
"\tif(Border) cval = corner(_xy);\n"
"\n"
"\t_xy = (floor(ratio_scale) + 0.5) / resolution;\n"
"\n"
"\tvec4 coeffs = PI * vec4(1.0 + uv_ratio.x, uv_ratio.x, 1.0 - uv_ratio.x, 2.0 - uv_ratio.x);\n"
"\n"
"\tcoeffs = FIX(coeffs);\n"
"\tcoeffs = 2.0 * sin(coeffs) * sin(coeffs / 2.0) / (coeffs * coeffs);\n"
"\n"
"\tcoeffs /= dot(coeffs, vec4(1.0));\n"
"\n"
"\tvec4 col  = clamp(coeffs.x * TEX2D(_xy + vec2(-one.x, 0.0))   + coeffs.y * TEX2D(_xy)+ coeffs.z * TEX2D(_xy + vec2(one.x, 0.0)) + coeffs.w * TEX2D(_xy + vec2(2.0 * one.x, 0.0)),   0.0, 1.0);\n"
"\tvec4 col2 = clamp(coeffs.x * TEX2D(_xy + vec2(-one.x, one.y)) + coeffs.y * TEX2D(_xy + vec2(0.0, one.y)) + coeffs.z * TEX2D(_xy + one)+ coeffs.w * TEX2D(_xy + vec2(2.0 * one.x, one.y)), 0.0, 1.0);\n"
"\n"
"\tvec4 rgba = texture2D(texture0, _xy);\n"
"\tvec4 intensity;\n"
"\t\n"
"\tif(fract(gl_FragCoord.y * (0.5 * 1.5 / 3.0)) > 0.5) intensity = vec4(0);\n"
"\telse intensity = smoothstep(0.2, 0.5, rgba) + normalize(rgba);\n"
"\n"
"\tvec4 weights  = scanlineWeights(uv_ratio.y, col);\n"
"\tvec4 weights2 = scanlineWeights(1.0 - uv_ratio.y, col2);\n"
"\t\n"
"\tvec3 mul_res = intensity.rgb + (col * weights + col2 * weights2).rgb * cval;\n"
"\t\n"
"\tfloat mod_factor = fragTexCoord.x * resolution.x;\n"
"\n"
"\tvec3 dotMaskWeights = mix( vec3(1.0, 0.7, 1.0), vec3(0.7, 1.0, 0.7), floor(mod(mod_factor, ScanlineIntensity)) );\n"
"\tmul_res *= dotMaskWeights * Brightness;\n"
"\n"
"\tif (Border) {\n"
"\t\tmul_res = pow(abs(mul_res), vec3(1.0 / (2.0 * Gamma - MonitorGamma))) * vec3(cval);\n"
"\t} else {\n"
"\t\tmul_res = pow(abs(mul_res), vec3(1.0 / ( 2.0 * Gamma - MonitorGamma)));\n"
"\t}\n"
"\n"
"\tfinalColor = vec4(mul_res, 1.0);\n"
"}\n"
""
